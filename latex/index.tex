\subsection*{What is {\ttfamily Lazy$<$T$>$}?}

{\ttfamily Lazy$<$T$>$} is a lightweight lazy-\/loading wrapper around any arbitrary class {\ttfamily T} written in modern C++.

All {\ttfamily Lazy} objects have their construction deferred until the latest possible time to ensure the laziest construction. Upon invocation of a member function, the {\ttfamily Lazy$<$T$>$} will instantiate type {\ttfamily T} by forwarding {\ttfamily T} the arguments originally supplied with the construction of the {\ttfamily Lazy}.

Here\textquotesingle{}s an example of {\ttfamily Lazy} in action\+: 
\begin{DoxyCode}
1 \{c++\}
2 auto lazy\_string = lazy::make\_lazy<std::string>("Hello world!");
3 // Creates Lazy object, doesn't construct std::string
4 
5 // ... do other operations
6 
7 std::cout << *lazy\_string << "\(\backslash\)n"; 
8 //           ^----------^
9 //           Constructs the std::string here for first use here
10 
11 lazy\_string->resize(10); // Already constructed, using the same std::string
\end{DoxyCode}


{\itshape It\textquotesingle{}s good to be lazy!}

This library has been written with an emphasis on performance, and aims to reduce unnecessary overhead due to redundant instantiations or duplications. In order to achieve this, deferred argument construction takes copies of all arguments to be passed to the constructor and, at construction time, will use move semantics to invoke the construction of the object. This reduces the need to pay for the cost of duplicate copies, to a cost of copy-\/and-\/move instead.

\subsection*{Why {\ttfamily Lazy$<$T$>$}?}

Certain objects may be expensive to construct, especially when they perform complex algorithms, async callbacks, and connections to outside systems. In situations where these objects may not be used within all possible execution paths, this can result in wasted cpu cycles.

Often, a lazy-\/initialization pattern is implemented within the class for the specific-\/case where it is needed, resulting in a lot of boilerplate code, and possible areas of failure.

{\ttfamily Lazy$<$T$>$} seeks to make it easier to lazily-\/initialize entries by handling all of the work with a simple tested A\+PI that behaves like a standard c++ smart pointer.

\subsection*{How to Use}

\subsubsection*{Inclusion}

{\ttfamily Lazy$<$T$>$} is a header-\/only library, making it easy to drop into any new project.

To start using, add a {\ttfamily -\/I} to the {\ttfamily include/} directory, and include the header {\ttfamily \hyperlink{_lazy_8hpp}{lazy/\+Lazy.\+hpp}} from the project.


\begin{DoxyCode}
1 \{c++\}
2 #include <lazy/Lazy.hpp>
3 
4 // use lazy::Lazy<T> 
\end{DoxyCode}


\subsubsection*{{\ttfamily Lazy$<$T$>$} Objects}

All {\ttfamily Lazy} objects have {\ttfamily operator-\/$>$} and {\ttfamily operator$\ast$} overloaded, making them behave similar to a smart pointer or an iterator. The underlying type will remain uninstantiated until such time that certain functions are accessed -- such as when the operators {\ttfamily -\/$>$} or {\ttfamily $\ast$} are accessed. At which point it will attempt a construction of the underlying type {\ttfamily T}.

This means that the type managed by a {\ttfamily Lazy} does {\itshape not} require a default or trivial constructor in order for this to properly operate; it simply requires a function to inform it how to instantiate the type at a later point.

\subsubsection*{Construction}

There are various ways to construct lazy objects through {\ttfamily Lazy$<$T$>$} depending on the required needs.


\begin{DoxyEnumerate}
\item Default construction
\item {\ttfamily make\+\_\+lazy$<$T$>$} utility for forwarding arguments
\item Function delegation for manually specifying construction/destruction behavior
\item Copy/\+Move construction/assignment
\end{DoxyEnumerate}

\paragraph*{1. Default Construction}

If you have a type that is to be lazily constructed with the default or trivial constructor, use the default constructor for the {\ttfamily Lazy} class. This isn\textquotesingle{}t particularly exciting, but this is the default behavior.


\begin{DoxyCode}
1 \{c++\}
2 auto lazy\_foo = lazy::Lazy<Foo>();
3 
4 // ...
5 
6 lazy\_foo->do\_something(); // constructs Foo object with Foo()
\end{DoxyCode}


\paragraph*{2. {\ttfamily make\+\_\+lazy$<$T$>$} Utility Function}

If no custom logic is required to construct the type {\ttfamily T} other than the constructor arguments, then you can easily make use of the {\ttfamily lazy\+::make\+\_\+lazy$<$T$>$(...)} utility function.

{\ttfamily make\+\_\+lazy} behaves similarly to {\ttfamily std\+::make\+\_\+shared} and {\ttfamily std\+::make\+\_\+unique} in that it forwards its arguments to the underlying type. The difference is that these arguments are stored until which time that the {\ttfamily Lazy} object is constructed for its first use.

Note that this means that arguments supplied to {\ttfamily make\+\_\+lazy} will require a copy constructor, since copies are used. This is necessary to avoid dangling reference problems when the values passed go out of scope prior to construction of the object.

An example of using {\ttfamily make\+\_\+lazy}\+: 
\begin{DoxyCode}
1 \{c++\}
2 
3 auto lazy\_string = lazy::make\_lazy<std::string>("Hello World",5);
4 
5 // do something
6 
7 std::cout << *lazy\_string << std::endl; 
8 //           ^~~~~~~~~~~^
9 //           Constructs std::string with the constructor std::string(const char*, size\_t)
\end{DoxyCode}


\paragraph*{3. Function delegation}

If more complex logic is required for the construction of the {\ttfamily T} object, you can supply a construction (and optionally destruction) function-\/like object (function pointer, member-\/function,functor, or lambda).

The {\itshape construction} function simple must return a {\ttfamily std\+::tuple} containing the types that will be forwarded to the constructor (I recommend making use of {\ttfamily std\+::make\+\_\+tuple} to simplify this).

The {\itshape destruction} function must take type {\ttfamily T\&} as a parameter and return {\ttfamily void}. The purpose of the destruction function is to give the chance to clean up anything that may not be managed by a destructor (or, in the case of using fundamental types like pointers, the chance to delete). The {\itshape destruction} function will be called prior to calling {\ttfamily T}\textquotesingle{}s destructor.

An example of where this may become useful\+: 
\begin{DoxyCode}
1 \{c++\}
2 auto open\_file = []()\{
3   return std::make\_tuple(fopen("some/file/path","r"));
4 \};
5 auto close\_file = [](FILE* ptr)\{
6   fclose(ptr);
7 \};
8 auto lazy\_file = lazy::Lazy<FILE*>(open\_file,close\_file);
9 
10 // somewhere else
11 use\_file(*lazy\_file); // constructs the lazy file object
\end{DoxyCode}
 \paragraph*{4. Copy/\+Move Constructor/\+Assignment}

A {\ttfamily Lazy} object is able to be constructed out of an instance of the underlying type {\ttfamily T} through copy or move construction. The same can also be done with instances of {\ttfamily Lazy$<$T$>$} as well.

In the case of {\ttfamily T} objects, the types will be used for deferred construction later on through a call to the copy or move constructors. In the case of {\ttfamily Lazy$<$T$>$} objects, they are constructed immediately, provided the {\ttfamily Lazy} being copied or moved has also itself been instantiated. If it is not, only the construction/destruction functions are copied or moved.

Similarly, the {\ttfamily Lazy} objects can be assigned to other {\ttfamily Lazy} objects, or directly to the type {\ttfamily T}. For assignments to type {\ttfamily T}, if the lazy is not already constructed, it will lazily construct itself prior to assignment to avoid the need for a copy or move constructor. For assignments to type {\ttfamily Lazy}, if the lazy being assigned is already initialized, the value will be assigned to the currently constructed {\ttfamily Lazy}. If it is uninitialized, only the constructor to the type will be assigned to defer instantiation until later use.

Examples\+: 
\begin{DoxyCode}
1 \{c++\}
2 auto a = lazy::make\_lazy<std::string>("Hello world");
3 auto b = a; // copy construction
\end{DoxyCode}


\subsection*{\label{_tested-compilers}%
 Tested Compilers}

The following compilers are currently being tested through continuous integration with \href{https://travis-ci.org/bitwizeshift/Lazy}{\tt Travis}.

Note that {\ttfamily Lazy} only works on compiler that provide proper conformance for c++11, meaning this does not properly work on g++ before 4.\+8

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Compiler }&{\bf Operating System  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Compiler }&{\bf Operating System  }\\\cline{1-2}
\endhead
g++ 4.\+9.\+3 &Ubuntu 14.\+04.\+3 T\+LS \\\cline{1-2}
g++ 5.\+3.\+0 &Ubuntu 14.\+04.\+3 T\+LS \\\cline{1-2}
g++ 6.\+1.\+1 &Ubuntu 14.\+04.\+3 T\+LS \\\cline{1-2}
clang 3.\+5.\+0 &Ubuntu 14.\+04.\+3 T\+LS \\\cline{1-2}
clang 3.\+6.\+2 &Ubuntu 14.\+04.\+3 T\+LS \\\cline{1-2}
clang 3.\+8.\+0 &Ubuntu 14.\+04.\+3 T\+LS \\\cline{1-2}
clang xcode 6.\+0 &Darwin Kernel 13.\+4.\+0 (O\+SX 10.\+9.\+5) \\\cline{1-2}
clang xcode 6.\+1 &Darwin Kernel 14.\+3.\+0 (O\+SX 10.\+10.\+3) \\\cline{1-2}
clang xcode 7.\+0 &Darwin Kernel 14.\+5.\+0 (O\+SX 10.\+10.\+5) \\\cline{1-2}
clang xcode 7.\+3 &Darwin Kernel 15.\+5.\+0 (O\+SX 10.\+11.\+5) \\\cline{1-2}
clang xcode 8.\+0 &Darwin Kernel 15.\+6.\+0 (O\+SX 10.\+11.\+6) \\\cline{1-2}
\end{longtabu}
\subsubsection*{More}

If any issues or bugs are encountered, please raise them through the \href{https://github.com/bitwizeshift/Lazy/issues}{\tt Github Issues Page}.

Other than that, this library is licensed under \href{#S-license}{\tt M\+IT}, so feel free to make use of it and enjoy!

\subsection*{\label{_S-license}%
 License}



The class is licensed under the \href{http://opensource.org/licenses/MIT}{\tt M\+IT License}\+:

Copyright \copyright{} 2016 \href{http://rodusek.me/}{\tt Matthew Rodusek}

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \char`\"{}\+Software\char`\"{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \char`\"{}\+A\+S I\+S\char`\"{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND, E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED, I\+N\+C\+L\+U\+D\+I\+NG B\+UT N\+OT L\+I\+M\+I\+T\+ED TO T\+HE W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY, F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+ND N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+NT. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE A\+U\+T\+H\+O\+RS OR C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY C\+L\+A\+IM, D\+A\+M\+A\+G\+ES OR O\+T\+H\+ER L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN AN A\+C\+T\+I\+ON OF C\+O\+N\+T\+R\+A\+CT, T\+O\+RT OR O\+T\+H\+E\+R\+W\+I\+SE, A\+R\+I\+S\+I\+NG F\+R\+OM, O\+UT OF OR IN C\+O\+N\+N\+E\+C\+T\+I\+ON W\+I\+TH T\+HE S\+O\+F\+T\+W\+A\+RE OR T\+HE U\+SE OR O\+T\+H\+ER D\+E\+A\+L\+I\+N\+GS IN T\+HE S\+O\+F\+T\+W\+A\+RE. 