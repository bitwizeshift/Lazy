<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Lazy: Lazy&lt;T&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lazy
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lazy&lt;T&gt; </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>What is <code>Lazy&lt;T&gt;</code>?</h2>
<p><code>Lazy&lt;T&gt;</code> is a lightweight lazy-loading wrapper around any arbitrary class <code>T</code> written in modern C++.</p>
<p>All <code>Lazy</code> objects have their construction deferred until the latest possible time to ensure the laziest construction. Upon invocation of a member function, the <code>Lazy&lt;T&gt;</code> will instantiate type <code>T</code> by forwarding <code>T</code> the arguments originally supplied with the construction of the <code>Lazy</code>.</p>
<p>Here's an example of <code>Lazy</code> in action: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto lazy_string = lazy::make_lazy&lt;std::string&gt;(&quot;Hello world!&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// Creates Lazy object, doesn&#39;t construct std::string</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// ... do other operations</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;std::cout &lt;&lt; *lazy_string &lt;&lt; &quot;\n&quot;; </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;//           ^----------^</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;//           Constructs the std::string here for first use here</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;lazy_string-&gt;resize(10); // Already constructed, using the same std::string</div></div><!-- fragment --><p><em>It's good to be lazy!</em></p>
<p>This library has been written with an emphasis on performance, and aims to reduce unnecessary overhead due to redundant instantiations or duplications. In order to achieve this, deferred argument construction takes copies of all arguments to be passed to the constructor and, at construction time, will use move semantics to invoke the construction of the object. This reduces the need to pay for the cost of duplicate copies, to a cost of copy-and-move instead.</p>
<h2>Why <code>Lazy&lt;T&gt;</code>?</h2>
<p>Certain objects may be expensive to construct, especially when they perform complex algorithms, async callbacks, and connections to outside systems. In situations where these objects may not be used within all possible execution paths, this can result in wasted cpu cycles.</p>
<p>Often, a lazy-initialization pattern is implemented within the class for the specific-case where it is needed, resulting in a lot of boilerplate code, and possible areas of failure.</p>
<p><code>Lazy&lt;T&gt;</code> seeks to make it easier to lazily-initialize entries by handling all of the work with a simple tested API that behaves like a standard c++ smart pointer.</p>
<h2>How to Use</h2>
<h3>Inclusion</h3>
<p><code>Lazy&lt;T&gt;</code> is a header-only library, making it easy to drop into any new project.</p>
<p>To start using, add a <code>-I</code> to the <code>include/</code> directory, and include the header <code><a class="el" href="_lazy_8hpp.html" title="This is the main include file for the Lazy library. ">lazy/Lazy.hpp</a></code> from the project.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;lazy/Lazy.hpp&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// use lazy::Lazy&lt;T&gt; </div></div><!-- fragment --><h3><code>Lazy&lt;T&gt;</code> Objects</h3>
<p>All <code>Lazy</code> objects have <code>operator-&gt;</code> and <code>operator*</code> overloaded, making them behave similar to a smart pointer or an iterator. The underlying type will remain uninstantiated until such time that certain functions are accessed &ndash; such as when the operators <code>-&gt;</code> or <code>*</code> are accessed. At which point it will attempt a construction of the underlying type <code>T</code>.</p>
<p>This means that the type managed by a <code>Lazy</code> does <em>not</em> require a default or trivial constructor in order for this to properly operate; it simply requires a function to inform it how to instantiate the type at a later point.</p>
<h3>Construction</h3>
<p>There are various ways to construct lazy objects through <code>Lazy&lt;T&gt;</code> depending on the required needs.</p>
<ol type="1">
<li>Default construction</li>
<li><code>make_lazy&lt;T&gt;</code> utility for forwarding arguments</li>
<li>Function delegation for manually specifying construction/destruction behavior</li>
<li>Copy/Move construction/assignment</li>
</ol>
<h4>1. Default Construction</h4>
<p>If you have a type that is to be lazily constructed with the default or trivial constructor, use the default constructor for the <code>Lazy</code> class. This isn't particularly exciting, but this is the default behavior.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto lazy_foo = lazy::Lazy&lt;Foo&gt;();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// ...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;lazy_foo-&gt;do_something(); // constructs Foo object with Foo()</div></div><!-- fragment --><h4>2. <code>make_lazy&lt;T&gt;</code> Utility Function</h4>
<p>If no custom logic is required to construct the type <code>T</code> other than the constructor arguments, then you can easily make use of the <code>lazy::make_lazy&lt;T&gt;(...)</code> utility function.</p>
<p><code>make_lazy</code> behaves similarly to <code>std::make_shared</code> and <code>std::make_unique</code> in that it forwards its arguments to the underlying type. The difference is that these arguments are stored until which time that the <code>Lazy</code> object is constructed for its first use.</p>
<p>Note that this means that arguments supplied to <code>make_lazy</code> will require a copy constructor, since copies are used. This is necessary to avoid dangling reference problems when the values passed go out of scope prior to construction of the object.</p>
<p>An example of using <code>make_lazy</code>: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;auto lazy_string = lazy::make_lazy&lt;std::string&gt;(&quot;Hello World&quot;,5);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// do something</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;std::cout &lt;&lt; *lazy_string &lt;&lt; std::endl; </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;//           ^~~~~~~~~~~^</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;//           Constructs std::string with the constructor std::string(const char*, size_t)</div></div><!-- fragment --><h4>3. Function delegation</h4>
<p>If more complex logic is required for the construction of the <code>T</code> object, you can supply a construction (and optionally destruction) function-like object (function pointer, member-function,functor, or lambda).</p>
<p>The <em>construction</em> function simple must return a <code>std::tuple</code> containing the types that will be forwarded to the constructor (I recommend making use of <code>std::make_tuple</code> to simplify this).</p>
<p>The <em>destruction</em> function must take type <code>T&amp;</code> as a parameter and return <code>void</code>. The purpose of the destruction function is to give the chance to clean up anything that may not be managed by a destructor (or, in the case of using fundamental types like pointers, the chance to delete). The <em>destruction</em> function will be called prior to calling <code>T</code>'s destructor.</p>
<p>An example of where this may become useful: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto open_file = [](){</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  return std::make_tuple(fopen(&quot;some/file/path&quot;,&quot;r&quot;));</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;};</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;auto close_file = [](FILE* ptr){</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  fclose(ptr);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;};</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;auto lazy_file = lazy::Lazy&lt;FILE*&gt;(open_file,close_file);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// somewhere else</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;use_file(*lazy_file); // constructs the lazy file object</div></div><!-- fragment --> <h4>4. Copy/Move Constructor/Assignment</h4>
<p>A <code>Lazy</code> object is able to be constructed out of an instance of the underlying type <code>T</code> through copy or move construction. The same can also be done with instances of <code>Lazy&lt;T&gt;</code> as well.</p>
<p>In the case of <code>T</code> objects, the types will be used for deferred construction later on through a call to the copy or move constructors. In the case of <code>Lazy&lt;T&gt;</code> objects, they are constructed immediately, provided the <code>Lazy</code> being copied or moved has also itself been instantiated. If it is not, only the construction/destruction functions are copied or moved.</p>
<p>Similarly, the <code>Lazy</code> objects can be assigned to other <code>Lazy</code> objects, or directly to the type <code>T</code>. For assignments to type <code>T</code>, if the lazy is not already constructed, it will lazily construct itself prior to assignment to avoid the need for a copy or move constructor. For assignments to type <code>Lazy</code>, if the lazy being assigned is already initialized, the value will be assigned to the currently constructed <code>Lazy</code>. If it is uninitialized, only the constructor to the type will be assigned to defer instantiation until later use.</p>
<p>Examples: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto a = lazy::make_lazy&lt;std::string&gt;(&quot;Hello world&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;auto b = a; // copy construction</div></div><!-- fragment --><h2><a class="anchor" id="tested-compilers"></a> Tested Compilers</h2>
<p>The following compilers are currently being tested through continuous integration with <a href="https://travis-ci.org/bitwizeshift/Lazy">Travis</a>.</p>
<p>Note that <code>Lazy</code> only works on compiler that provide proper conformance for c++11, meaning this does not properly work on g++ before 4.8</p>
<table class="doxtable">
<tr>
<th>Compiler </th><th>Operating System  </th></tr>
<tr>
<td>g++ 4.9.3 </td><td>Ubuntu 14.04.3 TLS </td></tr>
<tr>
<td>g++ 5.3.0 </td><td>Ubuntu 14.04.3 TLS </td></tr>
<tr>
<td>g++ 6.1.1 </td><td>Ubuntu 14.04.3 TLS </td></tr>
<tr>
<td>clang 3.5.0 </td><td>Ubuntu 14.04.3 TLS </td></tr>
<tr>
<td>clang 3.6.2 </td><td>Ubuntu 14.04.3 TLS </td></tr>
<tr>
<td>clang 3.8.0 </td><td>Ubuntu 14.04.3 TLS </td></tr>
<tr>
<td>clang xcode 6.0 </td><td>Darwin Kernel 13.4.0 (OSX 10.9.5) </td></tr>
<tr>
<td>clang xcode 6.1 </td><td>Darwin Kernel 14.3.0 (OSX 10.10.3) </td></tr>
<tr>
<td>clang xcode 7.0 </td><td>Darwin Kernel 14.5.0 (OSX 10.10.5) </td></tr>
<tr>
<td>clang xcode 7.3 </td><td>Darwin Kernel 15.5.0 (OSX 10.11.5) </td></tr>
<tr>
<td>clang xcode 8.0 </td><td>Darwin Kernel 15.6.0 (OSX 10.11.6) </td></tr>
</table>
<h3>More</h3>
<p>If any issues or bugs are encountered, please raise them through the <a href="https://github.com/bitwizeshift/Lazy/issues">Github Issues Page</a>.</p>
<p>Other than that, this library is licensed under <a href="#S-license">MIT</a>, so feel free to make use of it and enjoy!</p>
<h2><a class="anchor" id="S-license"></a> License</h2>
<div class="image">
<img src="http://opensource.org/trademarks/opensource/OSI-Approved-License-100x137.png"  align="right"/>
</div>
<p>The class is licensed under the <a href="http://opensource.org/licenses/MIT">MIT License</a>:</p>
<p>Copyright &copy; 2016 <a href="http://rodusek.me/">Matthew Rodusek</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
